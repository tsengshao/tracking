\documentclass[11pt]{article}
%\usepackage{bbm}
%\usepackage{graphics}
%\usepackage{german}
\sloppy
\textheight24cm
\textwidth17cm
\voffset-2cm
\hoffset-2.5cm

\begin{document}
\title{Iterative Rain Cell Tracking Software Manual}
\author{Christopher Moseley, Jan Haerter}
\date{\today}
\maketitle

\section{License}

The Iterative Rain cell Tracking (IRT) software can be distributed and modified freely for non-commercial use. Reference for the tracking method:
\begin{itemize}
\item C. Moseley, O. Henneberg, and J. O. Haerter (2019): A statistical model for isolated convective precipitation events. Journal of Advances in Modeling Earth Systems, {\bf 11}, 360-375, doi:10.1029/2018MS001383
\end{itemize}

\section{Software Requirements}

\begin{itemize}
\item It is recommended to use the IRT code on a {\bf Linux or UNIX system}.
\item {\bf A standard Fortan 90 compiler:} The IRT code is written completely in Fortran 90. It can be compiled by any standard fortran compiler, e.g. the GNU compiler ``gfortran''. The code is currently not paralellized.
\item {\bf Climate Data Operators (CDO):} The IRT software uses the SERVICE format (file ending ``.srv'') for input and output data sets, since this format is easy to handle in Fortan 90 and no additional libraries have to be included. As data sets are usually given in more wide spread formats like NetCDF, they have to be converted to SERVICE first. This is conveniently possible with the CDO software. It is freely available through  https://code.mpimet.mpg.de/projects/cdo/
\end{itemize}

\section{Files included in the IRT package}

{\bf irt\_objects\_release.f90}\\
The Fortran 90 code of the program that identifies spatially connected objects for every time step independently, and establishes links between objects of subsequent time steps. Input data in SERVICE format: The data file of the tracked field, additional field which are to be averaged over the track life cycles (optionally), and the field of the advection velocity on a coarse grid (optionally). Output: Object data (ASCII format), mask of object IDs (SERVICE format). \vspace{0.5cm} \\
%--------------------
{\bf irt\_advection\_field\_release.f90}\\
The Fortran 90 code of the program that generated the field of the advection velocity on a coarser spatial and temporal grid that is used for the next iteration of irt\_objects\_release.f90. Input data: The object data output file of by irt\_objects\_release.f90. Output data: The coarse velocity field (SERVICE format). \vspace{0.5cm} \\
%--------------------
{\bf irt\_tracks\_release.f90}\\
The Fortran 90 code of the program that forms tracks out of the identified objects. Input data: The object data output file of by irt\_objects\_release.f90. Output data in ASCII format: Track data with all available information and a header line of every track, and track data with reduced information which is used as input for the program irt\_trackmask\_release.f90. \vspace{0.5cm} \\
%--------------------
{\bf irt\_trackmask\_release.f90}\\
The Fortran 90 code of the program that generates a mask with track IDs in SERVICE format. Input data: The (sorted) output of reduced information track data from irt\_tracks\_release.f90, and the field of object IDs generated by irt\_objects\_release.f90. \vspace{0.5cm} \\
%--------------------
{\bf irt\_tracklinks\_release.f90}\\
The Fortran 90 code of a program that finds the ``parent" tracks of a track that was initiated by merging or splitting, and the ``child" tracks of a track that was terminated by merging or splitting. Input data: Output of irt\_tracks\_release.f90. Output: Track data with extender header.  \vspace{0.5cm} \\
%--------------------
{\bf compile.sh}\\
A shell script to compile the code. \vspace{0.5cm} \\
%--------------------
{\bf iterate.sh}\\
A shell script to perform one IRT iteration automatically. \vspace{0.5cm} \\
%--------------------
{\bf irt\_objects\_input\_00.srv.gz}\\
A tutorial dataset for testing the IRT code. \vspace{0.5cm} \\
%--------------------
{\bf copy\_srv.f90}\\
Example program to demonstrate how to handle SRV files in Fortran. It simply reads in an input file in SRV format and copies it to an output file.

\section{Setting the parameters}\label{sec_parameters}

The parameters for the tracking have to be written hard-coded into the Fortran 90 file irt\_parameters.f90. This file has to be modified first, before the code can be compiled. The following parameters have to be set:\vspace{0.5cm} \\
%--------------------
{\bf Domain size:}\\
The domain size longitudinal and latitudinal direction is given by the parameters {\it domainsize\_x} and {\it domainsize\_y}, respectively. The domain size of an input field can be found e.g. by the calling the CDO command\\
{\it cdo griddes example\_dataset.nc}\, . \\
and the domainsize must be set according to the values of xsize and ysize in the output of the CDO command, i.e.\\
{\it INTEGER, PARAMETER    :: domainsize\_x = 960}\\
{\it INTEGER, PARAMETER    :: domainsize\_y = 960}\\
in the case of the tutorial dataset.\vspace{0.5cm} \\
%--------------------
{\bf Grid information:}\\
This is important for the calculation of the object areas in the first place. The switch\\
{\it LOGICAL, PARAMETER    :: llonlatgrid = .TRUE.}\\
states that the grid is given in geographical longitudes and latitudes. In this case the grid information has to provided by three parameters given in degrees, containing the latitude of the southern edge of the domain, and the grid spacing in zonal and meridional direction: \\
{\it REAL, PARAMETER       :: lat\_first = -45.}\\
{\it REAL, PARAMETER       :: lat\_inc = 0.1}\\
{\it REAL, PARAMETER       :: lon\_inc = 0.1}\\
In this case, the scale parameter\\
{\it REAL, PARAMETER       :: unit\_area = 12345.}\\
defines the area of a square measuring 1$^\circ$ in zonal and meridional direction (i.e. a value 12345 as in the example would measure the areas in km$^2$).

If {\it llonlatgrid} is set to {\it .FALSE.} all grid boxes have an equal area given by {\it unit\_area} (e.g. in an idealized model output with periodic boundary conditions). in this case, the parameters {\it lat\_first, lat\_inc, lon\_inc} have to be set to arbitrary values, but have no effect on the tracking output.
\vspace{0.5cm} \\
%--------------------
{\bf Switch for periodic/non-periodic boundary conditions:}\\
If periodic boundary conditions should be applied in x-direction, the switch {\it lperiodic\_x} has to be set to\\
{\it LOGICAL, PARAMETER    :: lperiodic\_x = .TRUE.}\\
Otherwise, it has to be set to\\
{\it LOGICAL, PARAMETER    :: lperiodic\_x = .FALSE.}\\
Likewise, the switch {\it lperiodic\_y} has to be set for periodicity in y-direction.\\
\vspace{0.5cm} \\
%--------------------
{\bf Cutoff value for the tracking field:}\\
A minimal {\it threshold} value has to be defined that decides if a grid point should be counted as belonging to an object or not. E.g. in the case of rain intensity, a grid point must have at least the intensity given by {\it threshold} to be counted as a precipitating patch. If precipitation intensity given in $mm/h$ is tracked,\\
{\it REAL, PARAMETER       :: threshold=1.0}\\
could be a reasonable choice. The value is required be the program {\it irt\_objects\_release.f90}.\vspace{0.5cm} \\
%--------------------
{\bf Minimum size of a patch:}\\
Patches which are smaller than {\it minimum\_size} grid points will be neglected. A reasonable choice may be:
{\it REAL, PARAMETER       :: minimum\_size=4.}\vspace{0.5cm} \\
%--------------------
{\bf Grid description of the coarse velocity field:}\\
The coarse advection velocity field is not needed for the first run of {\it irt\_objects\_release.f90} (i.e. the first iteration of IRT), but for all subsequent iterations. It is given in grid points per time interval. To define the spatial and temporal grid of the velocity field, the following parameters have to be set:
\begin{itemize}
\item The number of time steps in the input dataset can be found e.g. by running the CDO command\\
{\it cdo ntime example\_dataset.nc}\, ,\\
and the parameter {\it time\_steps} has to be set accordingly:\\
{\it INTEGER, PARAMETER    :: time\_steps = 120}
\item The number of time steps of the velocity field is {\it nt\_bins}, and the number of grid boxes in x- and y-direction are {\it nx\_bins} and {\it ny\_bins}, e.g.\\
{\it INTEGER, PARAMETER    ::  nt\_bins = 10}\\
{\it INTEGER, PARAMETER    ::  nx\_bins = 2}\\
{\it INTEGER, PARAMETER    ::  ny\_bins = 2}\\
In this case, the domain will be divided into $2\times 2$ equally spaced squares. The whole time series will be divided into {\it nt\_bins}$=10$ equally long time intervals, therefore the temporal resolution of the velocity dataset is one hour (the input dataset has 120 time steps with 5 minutes interval, i.e. is in total 10 hours long).
\end{itemize}\vspace{0.5cm}
%--------------------
{\bf Maximum velocity:}\\
The parameter {\it max\_velocity} is a threshold with the intent to filter out events with unrealisticly high diagnosed velocities. This filters out artifacts that could e.g. happen when patched which do not actually belong to the same event accidently overlap. A reasonable value could be\\
{\it REAL, PARAMETER       :: max\_velocity = 10.}\vspace{0.5cm} \\
%--------------------
{\bf Minimum sample size for advection velocity:}\\
If the sample size for the diagnostics of advection velocity is too small, the mans value could be too noisy. The parameter {\it min\_cells} gives the minimum sample size of cells that are required to assign a mean value to a velocity grid box. If the sample size is smaller, then the velocity of the grid box will be interpolated from the neighbouring grid boxes. A reasonable value could be\\
{\it INTEGER, PARAMETER    :: min\_cells = 10}\vspace{0.5cm} \\
%--------------------
{\bf Additional averaging fields:}\\
Besides reading in only the tracking field (i.e. rain intensity in case of the tutorial dataset), there is the option to read in additional fields that will be averaged over the track life cycles. This is controlled by the parameter {\it n\_fields}. If the tracking field should be the only input file, then it should be set to 0:\\
{\it INTEGER, PARAMETER    ::  n\_fields = 0} \\
If we want to study e.g. the life cycles of the convergence field inside the  tutorial file {\it example\_dataset.nc}, we can set {n\_fields}$=1$.
%--------------------
{\bf Controlling the sensitivity of tracks to merging and splitting events:}\\
The parameter {\it threshold\_ratio} controls if a merging/splitting event terminates tracks or not, and must have a value between 0 and 1. If {\it threshold\_ratio}$=0$, every such event leads to termination of all involved track. If {\it threshold\_ratio}$=1$, at every merging/spitting event the largest involved track is not terminated, while all others terminate. A more detailed descrition is given in Moseley {et al.} (2019). Example:\\
{\it REAL, PARAMETER       :: threshold\_ratio=0.5}\vspace{0.5cm} \\
%--------------------
{\bf Buffer sizes:}\\
The following parameters are just buffer sizes and do not affect the tracking results. They have to be increased if necessary.
\begin{itemize}
\item The maximum number of objects in a single time step: {\it max\_no\_of\_cells}
\item The maximum length of a track: {\it max\_length\_of\_track}
\item The maximum number of tracks at a single time step: {\it max\_no\_of\_tracks}
\end{itemize}\vspace{0.5cm}
%--------------------
{\bf Missing value:}\\
The parameter {\it miss} defines the missing value. If a value is less or equal than {\it miss} will be regarded as missing value. By default we use:\\
{\it REAL, PARAMETER       :: miss = -9999.}

\section{Compiling the code}\label{sec_compile}

After all parameters have to be adjusted in the Fotran 90 files, the code can be compiled. All code files can be compiled independently. The shell script {\it compile.sh} compiles all four Fortran 90 files with the GNU compiler ``gfortran''. If you use another compiler, you can adjust the variable {\it COMPILE\_COMMAND} in the script. The executables will be generated with the file ending ``.x''.

\section{Running the tracking}

In the following, we apply the tracking on the tutorial dataset {\it example\_dataset.nc}.\vspace{0.5cm} \\
%--------------------
{\bf Preparing input datasets:}\\
The NetCDF file {\it example\_dataset.nc} contains the variables {\it r\_int} (the rain intensity given in [$mm/h$]) and {\it conv\_h\_low} (the moisture convergence below 2000 $m$ given in [$mm/s$]). It is given on a $960\times 960$ grid with periodic boundary conditions and contains 120 time steps.

We use the intensity field as tracking field and the convergence field as additional averaging field. Using CDO, the fields should first be separated and converted into SERVICE format. There are {\it n\_fields}$+1$ input datsets, and they must have the file names {\it irt\_objects\_input\_00.srv} for the tracking field (here: rain intensity) and {\it irt\_objects\_input\_xx.srv} where xx$=01,02,\ldots$ for the additional fields:\\
{\it cdo -f srv selvar,r\_int example\_dataset.nc irt\_objects\_input\_00.srv}\\
{\it cdo -f srv selvar,conv\_h\_low example\_dataset.nc irt\_objects\_input\_01.srv}\\
The tutorial dataset does not contain missing values. If a dataset contains missing values, they must be set to {\it miss} (-9999 by default) before the conversion. This is possible with the CDO command {\it setmisstoc}, e.g.:\\
{\it cdo -f srv setmisstoc,-9999 $<$filename$>$.nc irt\_objects\_input.srv}\vspace{0.5cm}\\
\fbox{ \parbox{\textwidth}{
{\bf Note: Some CDO versions will convert the data to 64 bit double precision variables in the SRV file. If you compile the code for 32 bit single precision floating point values, this will cause the code to crash or produce garbage values. In this case, you have to use the option ``-b F32" in the CDO commands.}
}}\vspace{0.5cm}\\
%--------------------
{\bf Setting parameters:}\\
Before compiling, the following parameters have to be set as described in section \ref{sec_parameters}.\\
%{\it domainsize\_x}$=960$\\
%{\it domainsize\_y}$=960$\\
%{\it time\_steps}$=120$\\
%{\it lperiodic\_x}$=${\it .TRUE.}\\
%{\it lperiodic\_y}$=${\it .TRUE.}\\
%{\it cutoff}$=1.0$ \hspace{0.5cm} (try also different values here)\\
%{\it n\_fields}$=1$\\
%{\it input\_filename = (/"irt\_objects\_input.srv     ","irt\_objects\_input\_conv.srv"/)}\\
%For the coarse velocity field we choose:\\
%{\it nt\_bins = 10}\\
%{\it nx\_bins = 2}\\
%{\it ny\_bins = 2}\\
%The other parameters can be chosen arbitrarily. After all this is done, the code can be compiled as described in section \ref{sec_compile}.
\vspace{0.5cm}\\
%--------------------
{\bf Running first iteration:}\\
\begin{itemize}
\item {\bf Step 1:} The objects have to be identified by calling:\\
{\it ./irt\_objects\_release.x 1}\\
The argument ``1'' means that no advection velocity field will be read in. The program reads in the files {\it irt\_objects\_input.srv} and {\it irt\_objects\_input\_conv.srv}, and generates the output files {\it irt\_objects\_output.txt}, and {\it irt\_objects\_mask.srv}
\item {\bf Step 2:} To generate the coarse advection velocity field, call:\\
{\it ./irt\_advection\_field\_release.x}\\
The program reads in the file {\it irt\_objects\_output.txt}, and writes the advection velocity field into the file {\it irt\_advection\_field.srv} in SERVICE format.
\item {\bf Step 3:} Combining the identified objects to tracks is done by calling the program:\\
{\it ./irt\_tracks\_release.x}\\
It reads in the file {\it irt\_objects\_output.txt} and writes two output files: {\it irt\_tracks\_output.txt} containing the full tracks information, and the auxiliary file {\it irt\_tracks\_nohead\_output.txt} with reduced information. Then, add track links by calling:\\
{\it ./irt\_tracklinks\_release.x}\\
It reads in the file {\it irt\_tracks\_output.txt}, and writes out the file {\it irt\_tracklinks\_output.txt} with extended track headers.
\item {\bf Step 4:} The final step is to generate the SERVICE file with the mask of track IDs. Therefore, two steps have to be done: First, the auxiliary file {\it irt\_tracks\_nohead\_output.txt} has to be sorted with respect to time step (second column). With a Linux system, this can by done e.g by using the ``sort'' command:\\
{\it sort -n -k2 irt\_tracks\_nohead\_output.txt $>$ irt\_tracks\_sorted.txt}\\
In the second step, call the program:\\
{\it ./irt\_trackmask\_release.x}\\
It reads in the sorted file {\it irt\_tracks\_sorted.txt} and the mask of object IDs {\it irt\_objects\_mask.srv} and writes out the SERVICE file {\it irt\_tracks\_mask.srv}.
\end{itemize}\vspace{0.5cm}
%--------------------
{\bf Running second and subsequent iterations:}\\
After the first iteration has been run, the file {\it irt\_advection\_field.srv} exists which is needed to perform the second iteration. This can be done by calling:
{\it ./irt\_objects\_release.x 2}\\
Here, the argument ``2'' means that the velocity field will be read in and applied for the identification of overlaps between objects of consecutive time steps. Steps 2 to 4 are the same as for the first iteration. The procedure can be iterated until the velocity field converges. Note: In principle, it is possible to perform the second and all further iteration already after step 2, steps 3 and 4 do not have to be run every time necessarily.\vspace{0.5cm}\\
%--------------------
{\bf Shell script for the iteration process:}\\
The shell script {\it iterate.sh} performs all the above mentioned steps automatically, and saves the tracking result of every iteration in separate files. Call the script with:
{\it ./iterate.sh}\\

\section{Format of the output files}

This section explains the output files which are necessary for the analysis and visualization of the tracking results.\vspace{0.5cm}\\
%--------------------
{\bf Format of the objects data output file} {\it irt\_objects\_output.txt}\\
The data file is in text format. Each line contains information of one identified object (connected patch). The number of colums is 23$+2\times${\it n\_fields}, where {\it n\_fields} is the parameter defining the number of additional input fields as described in section \ref{sec_parameters}. The columns contain the following information:
\begin{enumerate}
\item Time step
\item Object ID1: ID of the object for the given time step (counting begins with 1 at every new time step). If 0, it means that no object was found at the given time step, and all values in the other columns will be set to 0.
\item Object ID2: ID of the object for the whole time series (counting is continued from one time step to the next)
\item Age1: Age of the cell (in time steps). A cell merger inherits the age of the {\it oldest} cell involved in the merging.
\item Age2: Age of the cell (in time steps). A cell merger inherits the age of the {\it largest} cell involved in the merging. Note that Age2$\le$Age1.
\item Area of the object in the units given in the grid information
\item Mean value of the tracked field, averaged over the object's area. If {\it n\_fields}$>0$, then the next {\it n\_fields} columns contain area-averages over the other input fields.
\item Minimum value of the tracked field within the object's area. If {\it n\_fields}$>0$, then the next {\it n\_fields} columns contain minimum values over the other input fields within the object.
\item Maximum value of the tracked field within the object's area. If {\it n\_fields}$>0$, then the next {\it n\_fields} columns contain maximum values over the other input fields within the object.
\item x coordinate (in grid boxes, starting with 1) of the object's most western point (i.e. smallest x-coordinate)
\item x coordinate of the object's most eastern point (i.e. largest x-coordinate)
\item y coordinate of the object's most southern point (i.e. smallest y-coordinate)
\item y coordinate of the object's most northern point (i.e. largest y-coordinate)
\item x coordinate of the weighted center of mass of the object
\item y coordinate of the weighted center of mass of the object
\item x component of the object's estimated velocity given in grid points per time step. Missing value if not detectable.
\item y component of the object's estimated velocity given in grid points per time step. Missing value if not detectable.
\item ID2 of the largest object of the next time step that overlaps with this object. If 0, no such object exists.
\item Area of the object given in the column before
\item ID2 of the second largest object of the next time step that overlaps with this object. If 0, no such object exists.
\item Area of the object given in the column before
\item ID2 of the largest object of the previous time step that overlaps with this object. If 0, no such object exists.
\item Area of the object given in the column before
\item ID2 of the second largest object of the previous time step that overlaps with this object. If 0, no such object exists.
\item Area of the object given in the column before
\end{enumerate}\vspace{0.5cm}
%--------------------
{\bf Format of the tracks data output file} {\it irt\_tracks\_output.txt} and {\it irt\_tracklinks\_output.txt}\\
The data file is in text format. Each track consists of a header line, followed by a track body. Tracks are separated by a dummy line containing the character *.
A {\bf track header line} consists of 5 or 9 columns (in {\it irt\_tracks\_output.txt} or {\it irt\_tracklinks\_output.txt}, respectively) containing the following information:
\begin{enumerate}
\item Track ID
\item Time step when track begins
\item Duration of the track in time steps
\item Code labeling the situation at the initiation of the track:\\
0: Track emerges by itself\\
1: Track is fragment of a splitting event\\
2: Track is result of merging event\\
-1: Track initiated by contact with missing values
\item Code labeling the situation at the termination of the track:\\
0: Track dissipated\\
1: Track terminated by merging event\\
2: Track terminated by splitting event\\
-1: Track terminated by contact with missing values
\item (Only in {\it irt\_tracklinks\_output.txt}) ID of largest ``parent track'' in case the track was initiated by merging or splitting. Zero if non-existent.
\item (Only in {\it irt\_tracklinks\_output.txt}) ID of second largest ``parent track''. Zero if non-existent.
\item (Only in {\it irt\_tracklinks\_output.txt}) ID of largest ``child track'' in case the track was terminated by merging or splitting. Zero if non-existent.
\item (Only in {\it irt\_tracklinks\_output.txt}) ID of second largest ``child track''. Zero if non-existent.
\end{enumerate}
The {\it track body} has one line for every time step of the track life time, with 12$+2\times${\it n\_fields} columns containing the following information:
\begin{enumerate}
\item Track ID
\item Time step
\item Object ID1
\item Object ID2
\item Object Age1 (in time steps)
\item Object Age2 (in time steps)
\item Area of the object in grid points
\item Mean value of the tracked field, averaged over the object's area. If {\it n\_fields}$>0$, then the next {\it n\_fields} columns contain area-averages over the other input fields.
\item Minimum value of the tracked field within the object's area. If {\it n\_fields}$>0$, then the next {\it n\_fields} columns contain minimum values over the other input fields within the object.
\item Maximum value of the tracked field within the object's area. If {\it n\_fields}$>0$, then the next {\it n\_fields} columns contain maximum values over the other input fields within the object.
\item x coordinate (in grid boxes, starting with 1) of the object's most western point (i.e. smallest x-coordinate)
\item x coordinate of the object's most eastern point (i.e. largest x-coordinate)
\item y coordinate of the object's most southern point (i.e. smallest y-coordinate)
\item y coordinate of the object's most northern point (i.e. largest y-coordinate)
\item x coordinate of the weighted center of mass of the object
\item y coordinate of the weighted center of mass of the object
\item x component of the object's estimated velocity given in grid points per time step. Missing value if not detectable (usually at the end of the track).
\item y component of the object's estimated velocity given in grid points per time step. Missing value if not detectable (usually at the end of the track).
\item ID2 of the largest object of the next time step that overlaps with this object. If 0, no such object exists.
\item ID2 of the second largest object of the next time step that overlaps with this object. If 0, no such object exists.
\item ID2 of the largest object of the previous time step that overlaps with this object. If 0, no such object exists.
\item ID2 of the second largest object of the previous time step that overlaps with this object. If 0, no such object exists.
\end{enumerate}\vspace{0.5cm}
%--------------------
{\bf Mask files in SERVICE format}\\
\begin{itemize}
\item The file {\it irt\_objects\_mask.srv} contains a mask of the identified objects and marks them with the object ID1. Objects which are neglected because they are too small, or because they touch missing values, are indicated by the value -1.
\item The file {\it irt\_tracks\_mask.srv} constains a mask of all objects and marks them with the track ID. Objects which belong to tracks that are neglected because they are only 1 time step long, or because they touch missing values, are indicated by the value -1. Modify the program {\it irt\_trackmask\_release.f90} if you wish to label the objects differently (e.g. by object age, or track type).
\item The masks can be converted to NetCDF e.g. by the CDO command\\
{\it cdo -f nc copy irt\_objects\_mask.srv irt\_objects\_mask.nc}\\
{\it cdo -f nc copy irt\_tracks\_mask.srv irt\_tracks\_mask.nc}
\end{itemize}

\end{document}

